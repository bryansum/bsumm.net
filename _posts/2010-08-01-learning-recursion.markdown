---
title: Scheming to learn recursion
layout: post
---

Reading [GÃ¶del, Escher, Bach](http://www.amazon.com/gp/product/0394756827) broadened my perspective on recursion and the idea of the pervasiveness of composition *of* self *with* self. Recursion is everywhere: in the Piaget's genetic epistemology, where new mental abstractions are based on existing ones; the actual neurological structure of our brain via feedback loops, and its digital analogue in neural networks; visicious and virtuous cycles in systems thinking and economics; fractals; and also in various programming languages, especially those with lamdba calculus roots.

One languages celebrating recursion is Guy Steele and Gerry Sussman's Scheme, a dialect of of Lisp known for its minimal syntax and library. Scheme was created partially as a teaching aid for introductory computer science courses at MIT. Lisp, in turn, has its roots as a theoretical language in the AI Lab in the late 50's. John McCarthy famously created it without intended it to be implemented; it took a student named Steve Russell to create the first interpreter. The [LISP 1.5 Programmers Manual](http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf), by McCarthy himself, remarkably implements the entirety of a Lisp interpreter in a single page (see Appendix B's definition of `eval`). 

However, my initial interest in Lisp began with Paul Graham's essays. He waxed eloquent in [Hackers and Painters](http://www.amazon.com/gp/product/0596006624) about "[Beating the Averages](http://www.paulgraham.com/avg.html)" in software development, about how business with limited human capital can and should be using programming languages that maximize their productivity via higher-level abstractions and meta-languages. Around the same time, I picked up a copy of Daniel Friedman's [Essentials of Programming Languages](http://www.amazon.com/gp/product/0262062178), an academic treatise on programming language theory that assumed a working knowledge of Scheme. Rather than diving headfirst into the text, I figured it would better to start small and work my way up.

What I'm reading now is [The Little Schemer](http://www.amazon.com/gp/product/0262560992), also by Daniel Friedman. This book's style is the complete opposite of *Essentials*; it assumes no experience programming, and works as a two-way dialogue, where the reader is encouraged to programming questions along the way. The tone is a tad absurd in the vein of [Why's Poignant Guide](http://mislav.uniqpath.com/poignant-guide/), with pages devoted as a tablemat for eating PB&J sandwiches. It's a quick read, but definitely worthwhile if you're looking for an entertaining weekend guide to recursive thinking. 

It's unfortunate that the syntax of Lisp has been its downfall to some degree, as its also one of language's strengths. M-Expressions as McCarthy originally intended them were made to provide a more familiar imperative facade to the language, but this translation never caught on, even with attempts in the 90's by Apple with Dylan to do just that. Whatever the reason, CS schools, most famously MIT, have phased out teaching Scheme in introductory computer science courses. There's an interesting argument for and against practicality in programming languages taught at the university level. Papert would argue that the first language you learn tends to influence your view of others, and in this case Scheme might be a good theoretical foundation for others, as it lays bare the essential theory of PLs at the outset. Python, on the other hand, has a strong resemblance to shorthand pseudocode, possibly favoring a more productive dialogue between man and machine given no prior experience. In any case the relevant [Lambda the Ultimate article](http://lambda-the-ultimate.org/node/1840) explores on the issue further. 


---
title: Scheming to learn recursion
layout: post
---

Reading [GÃ¶del, Escher, Bach](http://www.amazon.com/gp/product/0394756827) broadened my perspective on recursion and the idea of composition *of* self *with* self. Recursion is everywhere: in the Piagetian model of learning, where new mental abstractions are based on existing ones; the neurological structure of our brain via feedback loops, and its digital analogue in neural networks; visicious and virtuous cycles in systems thinking and economics; fractals; and also in various programming languages, especially those with lamdba calculus roots.

One languages celebrating recursion is Guy Steele and Gerry Sussman's Scheme, a dialect of of Lisp known for its minimal syntax and library, created partially as a teaching aid for introductory computer science courses at MIT. This is in contrast to Common Lisp (CL), a standardization of the many variants of MacLisp, also from murky swamps of the AI Lab at MIT, whose libraries grew organically over time to become a comprehensive toolset for programming in the large. 

My interest in Lisp began with Paul Graham's essays. [Hackers and Painters](http://www.amazon.com/gp/product/0596006624), a collection of essays from his personal blog, waxed eloquent in [Beating the Averages](http://www.paulgraham.com/avg.html), about how business with limited human capital can and should be using programming languages which maximize their production via higher-level abstractions and meta-languages, which Lisp *just so happens* to handle it quite well (Coincidentally, he has [a book](http://www.paulgraham.com/acl.html) about Lisp too). I had also skimmed through the [LISP 1.5 Programmers Manual](http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf), by John McCarthy himself, on recommendation by Alan Kay. Appendix B implements the entirety of a Lisp interpreter in a single page (see the definition of `eval`), a remarkable feat even to this day. Around the same time, I had also picked up a copy of Daniel Friedman's [Essentials of Programming Languages](http://www.amazon.com/gp/product/0262062178), an academic treatise on programming language theory that assumed a working knowledge of Scheme. Rather than diving headfirst into the text, I figured it would better to dip my toes in the shallow end.

What I'm reading now is [The Little Schemer](http://www.amazon.com/gp/product/0262560992), also by Daniel Friedman. This book's style is the complete opposite of *Essentials*; it assumes no experience programming, and works as a two-way dialogue, where the reader is encouraged to programming questions along the way. The tone is a tad absurd in the vein of [Why's Poignant Guide](http://mislav.uniqpath.com/poignant-guide/), although not to the point of comic book characters shouting *chunky bacon*, with time built in for expressly eating PB&J sandwiches. It's a quick read, but definitely worthwhile if you're looking for an entertaining weekend guide to recursive thinking. 

It's unfortunate that the syntax of Lisp has been its downfall to some degree, as its also one of language's strengths. M-Expressions, as McCarthy originally intended them, were made to provide a more familiar imperative facade to the language, but this never caught on, even with attempts in the 90's by Apple with Dylan to do just that. Whatever the reason, CS schools, most famously MIT, have phased out teaching Scheme in introductory computer science courses. There's an interesting argument for and against practicality in programming languages taught at the university level. Papert would argue that the first language you learn tends to influence your view of others, and in this case Scheme might be a good theoretical foundation for others, as it lays bare the essential theory of PLs at the outset. Python, on the other hand, has a strong resemblance to shorthand pseudocode, possibly favoring a more productive dialogue between man and machine given no prior experience. In any case the relevant [Lambda the Ultimate article](http://lambda-the-ultimate.org/node/1840) explores on the issue further. 

